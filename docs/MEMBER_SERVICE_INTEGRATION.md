# Member Service Integration Guide

## Overview

This document describes how the member service should integrate with the AI service to receive and process follow-up notes generated by the AI system.

## SQS Response Queue Setup

The member service should listen to the `ai-to-member-responses` SQS queue to receive processed follow-up notes from the AI service.

### Queue Configuration
- **Queue Name**: `ai-to-member-responses`
- **Message Format**: JSON
- **Visibility Timeout**: 30 seconds
- **Message Retention**: 14 days

## Response Message Format

### Successful Note Generation

```json
{
  "message_type": "followup_note_generated",
  "task_id": 12345,
  "person_id": "uuid-person-id",
  "generated_note": "AI-generated follow-up note content...",
  "ai_confidence_score": 0.85,
  "status": "completed",
  "timestamp": "2024-01-07T10:30:00Z",
  "source_service": "ai_service",
  "recommended_actions": [
    "Schedule follow-up call",
    "Send welcome package",
    "Assign to volunteer coordinator"
  ],
  "metadata": {
    "ai_model_version": "gpt-4",
    "processing_time": "2024-01-07T10:30:00Z",
    "tenant_id": 1
  }
}
```

### Error Response

```json
{
  "message_type": "followup_note_error",
  "task_id": 12345,
  "person_id": "uuid-person-id",
  "generated_note": "",
  "ai_confidence_score": 0.0,
  "status": "failed",
  "timestamp": "2024-01-07T10:30:00Z",
  "source_service": "ai_service",
  "error": "Error message describing what went wrong"
}
```

## Member Service Implementation

### 1. SQS Message Listener

```javascript
const AWS = require('aws-sdk');
const sqs = new AWS.SQS({ region: 'your-region' });

const RESPONSE_QUEUE_URL = 'https://sqs.your-region.amazonaws.com/account/ai-to-member-responses';

async function pollForAIResponses() {
  const params = {
    QueueUrl: RESPONSE_QUEUE_URL,
    MaxNumberOfMessages: 10,
    WaitTimeSeconds: 20,
    VisibilityTimeoutSeconds: 30
  };

  try {
    const result = await sqs.receiveMessage(params).promise();
    
    if (result.Messages) {
      for (const message of result.Messages) {
        await processAIResponse(JSON.parse(message.Body));
        
        // Delete processed message
        await sqs.deleteMessage({
          QueueUrl: RESPONSE_QUEUE_URL,
          ReceiptHandle: message.ReceiptHandle
        }).promise();
      }
    }
  } catch (error) {
    console.error('Error polling for AI responses:', error);
  }
}
```

### 2. Process AI Response

```javascript
async function processAIResponse(responseData) {
  const { 
    message_type, 
    task_id, 
    person_id, 
    generated_note, 
    ai_confidence_score, 
    status, 
    recommended_actions,
    error 
  } = responseData;

  try {
    if (message_type === 'followup_note_generated' && status === 'completed') {
      // Create note record in the database
      await createFollowUpNote({
        task_id,
        person_id,
        note_content: generated_note,
        note_type: 'ai_generated',
        confidence_score: ai_confidence_score,
        recommended_actions: recommended_actions || [],
        created_by: 'ai_service',
        created_at: new Date()
      });

      // Update task status if needed
      await updateTaskStatus(task_id, {
        ai_processing_status: 'completed',
        ai_confidence_score,
        last_ai_update: new Date()
      });

      console.log(`Follow-up note created for task ${task_id}`);
      
    } else if (message_type === 'followup_note_error' || status === 'failed') {
      // Handle error case
      await updateTaskStatus(task_id, {
        ai_processing_status: 'failed',
        ai_error_message: error,
        last_ai_update: new Date()
      });

      console.error(`AI processing failed for task ${task_id}: ${error}`);
    }
  } catch (dbError) {
    console.error('Database error processing AI response:', dbError);
    // Consider implementing retry logic or dead letter queue
  }
}
```

### 3. Database Schema Updates

#### Notes Table Enhancement

```sql
ALTER TABLE notes ADD COLUMN IF NOT EXISTS note_type VARCHAR(50) DEFAULT 'manual';
ALTER TABLE notes ADD COLUMN IF NOT EXISTS ai_confidence_score DECIMAL(3,2);
ALTER TABLE notes ADD COLUMN IF NOT EXISTS recommended_actions JSON;
ALTER TABLE notes ADD COLUMN IF NOT EXISTS ai_metadata JSON;

-- Index for AI-generated notes
CREATE INDEX IF NOT EXISTS idx_notes_ai_type ON notes(note_type) WHERE note_type = 'ai_generated';
```

#### Tasks Table Enhancement

```sql
ALTER TABLE tasks ADD COLUMN IF NOT EXISTS ai_processing_status VARCHAR(20) DEFAULT 'pending';
ALTER TABLE tasks ADD COLUMN IF NOT EXISTS ai_confidence_score DECIMAL(3,2);
ALTER TABLE tasks ADD COLUMN IF NOT EXISTS ai_error_message TEXT;
ALTER TABLE tasks ADD COLUMN IF NOT EXISTS last_ai_update TIMESTAMP;

-- Index for AI processing status
CREATE INDEX IF NOT EXISTS idx_tasks_ai_status ON tasks(ai_processing_status);
```

### 4. Note Creation Function

```javascript
async function createFollowUpNote(noteData) {
  const {
    task_id,
    person_id,
    note_content,
    note_type,
    confidence_score,
    recommended_actions,
    created_by
  } = noteData;

  const query = `
    INSERT INTO notes (
      task_id, 
      person_id, 
      note_content, 
      note_type, 
      ai_confidence_score, 
      recommended_actions,
      created_by,
      created_at,
      updated_at
    ) VALUES (?, ?, ?, ?, ?, ?, ?, NOW(), NOW())
  `;

  const values = [
    task_id,
    person_id,
    note_content,
    note_type,
    confidence_score,
    JSON.stringify(recommended_actions),
    created_by
  ];

  return await db.query(query, values);
}
```

### 5. Task Status Update Function

```javascript
async function updateTaskStatus(taskId, statusData) {
  const {
    ai_processing_status,
    ai_confidence_score,
    ai_error_message,
    last_ai_update
  } = statusData;

  const query = `
    UPDATE tasks 
    SET 
      ai_processing_status = ?,
      ai_confidence_score = ?,
      ai_error_message = ?,
      last_ai_update = ?,
      updated_at = NOW()
    WHERE id = ?
  `;

  const values = [
    ai_processing_status,
    ai_confidence_score,
    ai_error_message,
    last_ai_update || new Date(),
    taskId
  ];

  return await db.query(query, values);
}
```

## Error Handling and Retry Logic

### 1. Dead Letter Queue

Configure a dead letter queue for messages that fail processing multiple times:

```javascript
const DLQ_URL = 'https://sqs.your-region.amazonaws.com/account/ai-responses-dlq';

// Process messages from DLQ for manual review
async function processDLQMessages() {
  // Implementation for handling failed messages
}
```

### 2. Retry Logic

```javascript
async function processAIResponseWithRetry(responseData, maxRetries = 3) {
  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      await processAIResponse(responseData);
      return; // Success, exit retry loop
    } catch (error) {
      console.error(`Attempt ${attempt} failed:`, error);
      
      if (attempt === maxRetries) {
        // Send to DLQ or log for manual intervention
        await sendToDLQ(responseData, error);
        throw error;
      }
      
      // Wait before retry (exponential backoff)
      await new Promise(resolve => setTimeout(resolve, Math.pow(2, attempt) * 1000));
    }
  }
}
```

## Monitoring and Logging

### 1. Metrics to Track

- Messages processed per minute
- Processing success rate
- Average AI confidence scores
- Error rates by type
- Queue depth and processing latency

### 2. Logging

```javascript
const logger = require('winston');

// Log successful processing
logger.info('AI response processed', {
  task_id,
  person_id,
  confidence_score: ai_confidence_score,
  processing_time: Date.now() - startTime
});

// Log errors
logger.error('AI response processing failed', {
  task_id,
  error: error.message,
  stack: error.stack
});
```

## Testing

### 1. Unit Tests

```javascript
describe('AI Response Processing', () => {
  it('should create note for successful AI response', async () => {
    const mockResponse = {
      message_type: 'followup_note_generated',
      task_id: 123,
      person_id: 'test-person-id',
      generated_note: 'Test note',
      ai_confidence_score: 0.9,
      status: 'completed'
    };

    await processAIResponse(mockResponse);
    
    // Assert note was created
    const note = await getNoteByTaskId(123);
    expect(note.note_content).toBe('Test note');
    expect(note.ai_confidence_score).toBe(0.9);
  });
});
```

### 2. Integration Tests

```javascript
describe('SQS Integration', () => {
  it('should process messages from AI service queue', async () => {
    // Send test message to queue
    await sendTestMessage();
    
    // Process messages
    await pollForAIResponses();
    
    // Verify processing
    const task = await getTaskById(123);
    expect(task.ai_processing_status).toBe('completed');
  });
});
```

## Deployment Considerations

1. **Environment Variables**:
   - `AI_RESPONSE_QUEUE_URL`
   - `AWS_REGION`
   - `AWS_ACCESS_KEY_ID`
   - `AWS_SECRET_ACCESS_KEY`

2. **IAM Permissions**:
   ```json
   {
     "Version": "2012-10-17",
     "Statement": [
       {
         "Effect": "Allow",
         "Action": [
           "sqs:ReceiveMessage",
           "sqs:DeleteMessage",
           "sqs:GetQueueAttributes"
         ],
         "Resource": "arn:aws:sqs:region:account:ai-to-member-responses"
       }
     ]
   }
   ```

3. **Scaling**: Consider using multiple worker processes or containers to handle high message volumes.

4. **Health Checks**: Implement health check endpoints that verify SQS connectivity and processing status.
"""
Follow-up Notes API for AI-generated content.

Provides endpoints for generating AI follow-up notes with proper authentication.
Supports both authenticated (user + tenant) and internal (no auth) access patterns.
"""
from fastapi import APIRouter, HTTPException, BackgroundTasks, Depends
from typing import Dict, Any, Optional, Tuple
from pydantic import BaseModel
import logging
import time

from app.api.schemas.auth_user import UserResponse, TenantContextResponse
from app.security.dependencies import UserAndTenant, AIContext
from app.agents.followup_summary_agent import FollowupSummaryAgent

logger = logging.getLogger(__name__)

router = APIRouter(prefix="/followup-notes", tags=["Follow-up Notes"])

# Pydantic Models
class FollowupRequest(BaseModel):
    """Request model for follow-up note generation."""
    visitor_id: str
    context: Optional[str] = None
    priority: Optional[str] = "normal"

class FollowupResponse(BaseModel):
    """Response model for follow-up note generation."""
    note_id: str
    content: str
    visitor_id: str
    generated_by: str
    tenant_schema: str
    user_id: str

class InternalFollowupRequest(BaseModel):
    """Request model for internal follow-up note generation (SQS processing)."""
    visitor_id: str
    tenant_schema: str
    context: Optional[str] = None
    priority: Optional[str] = "normal"

class InternalFollowupResponse(BaseModel):
    """Response model for internal follow-up note generation."""
    note_id: str
    content: str
    visitor_id: str
    tenant_schema: str
    generated_by: str = "ai-automated"

@router.post(
    "/generate",
    response_model=FollowupResponse,
    summary="Generate Follow-up Note",
    description="Generate AI follow-up note with user and tenant authentication"
)
async def generate_followup_note(
    followup_request: FollowupRequest,
    auth: Tuple[UserResponse, TenantContextResponse] = UserAndTenant,
    background_tasks: BackgroundTasks = BackgroundTasks()
) -> FollowupResponse:
    """
    Generate AI-generated follow-up note with full authentication.
    
    Requires user and tenant authentication via headers:
    - X-auth-user: User context from central VecApp
    - X-request-tenant: Tenant context from central VecApp
    
    Args:
        followup_request: Request data including visitor_id and context
        auth: User and tenant context from headers
        background_tasks: Background task queue
    
    Returns:
        Generated follow-up note with metadata
    """
    user, tenant = auth
    
    try:
        # Initialize the followup agent
        followup_agent = FollowupSummaryAgent()
        
        # Generate personalized tenant-specific followup
        note_content = await followup_agent.generate_personalized_followup(
            visitor_id=followup_request.visitor_id,
            user_context=user,
            tenant_context=tenant,
            additional_context=followup_request.context
        )
        
        # Generate unique note ID
        note_id = f"note_{followup_request.visitor_id}_{user.id}_{int(time.time())}"
        
        # Schedule background analytics processing
        background_tasks.add_task(
            process_followup_analytics,
            note_id,
            str(user.id),
            tenant.id
        )
        
        logger.info(
            f"Follow-up note generated by user {user.username} "
            f"for visitor {followup_request.visitor_id} in tenant {tenant.schema_name}"
        )
        
        return FollowupResponse(
            note_id=note_id,
            content=note_content,
            visitor_id=followup_request.visitor_id,
            generated_by=f"ai-{user.username}",
            tenant_schema=tenant.schema_name,
            user_id=str(user.id)
        )
        
    except Exception as e:
        logger.error(f"Error generating follow-up note: {str(e)}")
        raise HTTPException(
            status_code=500,
            detail=f"Failed to generate follow-up note: {str(e)}"
        )

@router.post(
    "/internal/generate",
    response_model=InternalFollowupResponse,
    summary="Internal Follow-up Note Generation",
    description="Generate follow-up note for internal processing (SQS → AI Service → DB)"
)
async def generate_internal_followup_note(
    followup_request: InternalFollowupRequest
) -> InternalFollowupResponse:
    """
    Generate AI-generated follow-up note for internal processing.
    
    This endpoint is for internal use only (SQS processing).
    No authentication required as it's called from internal services.
    
    Args:
        followup_request: Request data including visitor_id and tenant_schema
    
    Returns:
        Generated follow-up note for internal processing
    """
    try:
        # Initialize the followup agent
        followup_agent = FollowupSummaryAgent()
        
        # Generate basic followup for internal processing
        note_content = await followup_agent.generate_tenant_followup(
            visitor_id=followup_request.visitor_id,
            tenant_schema=followup_request.tenant_schema,
            additional_context=followup_request.context
        )
        
        # Generate unique note ID
        note_id = f"internal_{followup_request.visitor_id}_{followup_request.tenant_schema}_{int(time.time())}"
        
        logger.info(
            f"Internal follow-up note generated for visitor {followup_request.visitor_id} "
            f"in tenant {followup_request.tenant_schema}"
        )
        
        return InternalFollowupResponse(
            note_id=note_id,
            content=note_content,
            visitor_id=followup_request.visitor_id,
            tenant_schema=followup_request.tenant_schema
        )
        
    except Exception as e:
        logger.error(f"Error generating internal follow-up note: {str(e)}")
        raise HTTPException(
            status_code=500,
            detail=f"Failed to generate internal follow-up note: {str(e)}"
        )

async def process_followup_analytics(note_id: str, user_id: str, tenant_id: int):
    """Background task to process follow-up analytics for authenticated users."""
    try:
        # Implementation for analytics processing
        logger.info(f"Processing analytics for note {note_id}, user {user_id}, tenant {tenant_id}")
        # Add your analytics processing logic here
    except Exception as e:
        logger.error(f"Error processing analytics: {str(e)}")

@router.get("/health")
async def followup_health_check():
    """Health check endpoint for follow-up notes service."""
    return {
        "status": "healthy",
        "service": "followup-notes",
        "message": "Follow-up notes service is operational"
    }
